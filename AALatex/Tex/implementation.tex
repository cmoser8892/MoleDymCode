\chapter{Implementation}
\begin{comment}	
	go about structure of the code 
	-> describe Code structure
		
	-> c++ was used to implement the code (mostly functional)
	-> key atoms container Class which holdes all the Values
	-> most functions were tested with googleTest
\end{comment}

%basic
\begin{comment}
code written in c++ most of it pretty functional, classes just used 
for the atoms container which holds the arrays 
while writing it also wrote the unittests with googletest
data aquiered form the code plotted with python
also where large simulations had to be run, called the program from the python code

\end{comment}
The simulation code was written in C++, most of it as functions, although the positions, velocities, etc. of the individual atoms were saved in a container-class.
While writing the functions, these were also tested with unit-tests.
Plot generation and automation for running the project were written in python.

%used software
\begin{comment}
developed in CLion which as an integrated git inviroment
Clion builds with Cmake then clang as a compiler
debugger is gdb(nicely hidden)
- additianal bibs where :
	googletest	for unittests
	eigen		for arrays 
- software used form the class itself 
- ovito for visualization
\end{comment}
The C++-code was developed in CLion, an IDE which bundles many useful features together (CMake, GDB and Git)\cite{clion}.
The python-code was written in jupyter-notebook. Alternatively, this could have been done directly in CLion with a plugin. 
Additional libraries used were: googletest \cite{googletest} for the unit-tests and eigen \cite{eigen} for the arrays used for data storage in the container-class. 
Further software from the course was used for reading xyz-data and for the implementation of the Neighborhood-Search and Gupta-Potential algorithms \cite{molDymCourse}. 
To be able to visualize and anaylse the results of the simulated clusters, the positions of the atoms were recorded and put into OVITO Basic \cite{ovito}.  

While using the embedded-atom method potential, it was necessary to generate a variety of different sized clusters in the form of an icosahedron. An external Mackay Icosahedron Structure Generator \cite{icosader}, was used for this.
\begin{comment}
--
code is structured into the milestones, so an individual milestone can be rerun in case of fuckup
parted into h and cpp files as usual
followed the structure of the milestone
\end{comment}

The code is partitioned into a headerfile (.h) and a codefile (.cpp). The functions were generally structured into a related header- and codefile. For example all functions regarding the Lenard-Jones-Potential can be found in an appropriately named filecombo. Furthermore a test file exists where the unit-tests can be found.
\par
The implementation itself followed the milestones given in the course and went up till milestone seven. 
In case any mistakes happened, the main of each milestone was saved into an extra file and can be commented back into the code again in the true main.cpp file. 
\par 
Independent of the milestones the code is generally structured similarly. It has to be noted that here just a generalization is given, and for further information it would be best to just look at the code itself as it should be well commented \cite{molDymGithub}.
\par 
In the first step the variables have to be initialized. For example the initial structure of the atoms, when and where to save data and the timestep of the verlet-integration have to be defined. Some of the initial parameters can also be given to the program externally. After the initialization the simulation is run in form of a loop. This main-loop is run for a number of times specified before. In the loop itself, the two verlet-steps, the calculation of the kinetic and potential energy, and the evaluation of the force at each atom, are executed. In later milestone a thermostat and other effects are added to the loop. 
After the main-loop the acquired data is saved into a file and then processed after the simulation itself with python. 
\par 
In python the contents of the data-file, which was generated from the C++-program is read and then ploted. In the later milestones the program was often directly called in python and more then one instance run in parallel to speed up the data-acquisition. 




