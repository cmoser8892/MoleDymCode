\chapter{Implementation}
\begin{comment}	
	go about structure of the code 
	-> describe Code structure
		
	-> c++ was used to implement the code (mostly functional)
	-> key atoms container Class which holdes all the Values
	-> most functions were tested with googleTest
\end{comment}

%basic
\begin{comment}
code written in c++ most of it pretty functional, classes just used 
for the atoms container which holds the arrays 
while writing it also wrote the unittests with googletest
data aquiered form the code plotted with python
also where large simulations had to be run, called the program from the python code

\end{comment}
%TODO cite shit
The simulation code was written in C++, most of it just as functions, although the positions, velocities, etc. of the individual atoms where saved in a container-class.
While writing the functions, these were also tested with unit-tests.
Plots generation and automation for running the project were written in python.

%used software
\begin{comment}
developed in CLion which as an integrated git inviroment
Clion builds with Cmake then clang as a compiler
debugger is gdb(nicely hidden)
- additianal bibs where :
	googletest	for unittests
	eigen		for arrays 
- software used form the class itself 
- ovito for visualization
\end{comment}
%TODO cluster generation
The C++-code was developed in CLion, an IDE which bundles many useful features together (CMake, GDB and Git).
The python-code was written in jupyter-notebook, alternatively this could also have been done directly in CLion with a plugin. 
Additional libaries used where: googletest \cite{googletest} for the unit-tests and eigen \cite{eigen} for the arrays used for data storage in the container-class. 
Further software form the course was used for reading xyz-data and for the implementation of the Neighborhood-Search and Gupta-Potential algorithms \cite{molDymCourse}. 
To visualize the simulation the positions of the atoms at a given time where recorded and then put into OVITO Basic \cite{ovito} to be able to look at them.
While using the embedded-atom method potential it was necessary to generate a variety of different sized clusters in the form of an icosahedron. For this an external Mackay Icosahedron Structure Generator \cite{icosader} was used.
\begin{comment}
--
code is structured into the milestones, so an individual milestone can be rerun in case of fuckup
parted into h and cpp files as usual
followed the structure of the milestone
\end{comment}

The code is parted into a headerfile (.h) and a codefile (.cpp). The functions where generally structured into a related header- and codefile. For example all functions regarding the Lenard-Jones-Potential can be found in an appropriately named filecombo. Furthermore a test file exists where the unit-tests can be found.
\par
The implementation itself just followed the milestones given in the course and went up till milestone seven. 
In case any mistakes happened the main of each milestone was saved into an extra file and just commented into the code again in the true main.cpp file. 
\par
For further information it would be best to just look at the code itself as it should be well commented \cite{molDymGithub}.




